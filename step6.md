最後の仕上げとして、蓄積された評価データを集約し、分析・可視化する機能を実装します。このステップでは、評価結果を隣接行列に変換し、ヒートマップで表示します。

**前提:**
*   ステップ5までのコードに追記・修正します。
*   `project_data['evaluations']` に複数の評価結果が保存されている状態を想定します。

**要件:**
1.  **ライブラリの追加:** `pandas`, `numpy`, `seaborn`, `matplotlib.pyplot` をインポートしてください。
2.  **UIの追加:**
    *   メイン画面に「5. 分析と可視化」という最上位の見出しを追加します。
    *   その下に「5.1. 隣接行列ヒートマップ」という小見出しと、「行列を生成して可視化」ボタンを設置してください。
3.  **行列生成ロジック:**
    *   「行列を生成して可視化」ボタンが押されたら、以下の処理を実行します。
    *   `project_data['evaluations']` が空の場合は、`st.warning` を表示して処理を中断してください。
    *   評価結果のリストを元に、Pandas DataFrame (`pd.DataFrame`) を作成します。カラムは `from_node`, `to_node`, `score` です。
    *   `DataFrame.pivot_table()` メソッドを使い、`index='from_node'`, `columns='to_node'`, `values='score'` を指定して、評価結果を隣接行列の形式に変換（ピボット）してください。
    *   ピボット後の行列には評価されなかったペアに対応する欠損値 (`NaN`) が含まれる可能性があります。`.fillna(0)` を使って、これらを `0` (無関係) で埋めてください。
    *   行列のインデックスとカラムが、`project_data['nodes']` の全てのノードを含み、かつ同じ順序になるように、`.reindex()` を使って整形してください。これにより、完全な正方行列が保証されます。
    *   完成したDataFrame（隣接行列）をNumPy配列に変換し、`project_data['adjacency_matrix']` に保存してください。
4.  **ヒートマップ可視化ロジック:**
    *   生成した行列（DataFrame形式のままが望ましい）を `seaborn.heatmap()` に渡してヒートマップを描画します。
    *   **ヒートマップのオプション:**
        *   `annot=True`: 各セルにスコア数値を表示します。
        *   `cmap='coolwarm'`: 色のマップを指定します。正の相関が暖色系、負の相関が寒色系になるようにします。
        *   `linewidths=.5`: セル間に線を描画します。
        *   `vmin=-9, vmax=9`: カラーバーの最小値と最大値を評価スケールに合わせます。
    *   `matplotlib.pyplot` を使って、グラフのタイトルや軸ラベルを適切に設定し、図のサイズを調整してください。
    *   最終的なグラフオブジェクトを `st.pyplot(fig)` を使ってStreamlit上に表示してください。
5.  **データ表示 (任意):**
    *   可視化の下に、生成された隣接行列のDataFrame自体を `st.dataframe()` で表示する機能も追加してください。

**コード品質への要求:**
*   データ変換（リスト→DataFrame→ピボット→行列）のパイプラインは、一つの関数にまとめるなどして、可読性を高く保ってください。
*   Matplotlib/Seabornの描画コードは定型的なので、コメントを付けて各行の役割を明確にしてください。

この要件を満たす更新コードを生成してください。