いよいよ、このアプリケーションで最も重要なロジック、LLMによるノード間影響評価を実装します。ユーザーが表示しているノードペアに対して、OpenAI APIに問い合わせを行い、その関係性を定量化します。

**前提:**
*   ステップ4までのコードに追記・修正します。
*   評価UIが表示されている状態を想定します。

**要件:**
1.  **UIの追加:**
    *   ノードペア表示の下に、「このペアの影響を評価」という目立つボタン (`st.button` の `type="primary"`) を設置してください。
2.  **LLM評価ロジック:**
    *   「このペアの影響を評価」ボタンが押されたら、以下の処理を実行します。
    *   `st.spinner("AIが評価中です...")` を使って、処理中であることをユーザーに示してください。
    *   現在の `evaluation_index` を使って、評価対象の `from_node` と `to_node` を取得します。
    *   以下の仕様でOpenAI API (Chat Completions) にリクエストを送信するプロンプトを構築してください。
        *   **役割 (ペルソナ):** あなたは生産技術に20年以上従事するベテランのコンサルタントです。インダストリアル・エンジニアリング（IE）の手法に精通しています。
        *   **文脈:** 今、`{process_name}` という生産プロセスについて分析しています。
        *   **タスク:** 「{from_node}」という工程/要素の性能を向上させるための変更が、「{to_node}」という工程/要素に与える影響を、思考プロセスと共に評価してください。
        *   **評価スケール (厳守):**
            *   +9: 強い正の相関 (直接的かつ大幅に改善される)
            *   +3: 正の相関 (改善される傾向にある)
            *   +1: 弱い正の相関
            *   0: 無関係
            *   -1: 弱い負の相関 (トレードオフ)
            *   -3: 負の相関 (一般的なトレードオフ)
            *   -9: 強い負の相関 (直接的かつ大幅に悪化する)
        *   **思考プロセス (必須):** 結論に至る前に、必ず以下のステップで思考を記述してください。
            1.  `from_node` と `to_node` の生産プロセスにおける関係性を説明する。
            2.  `from_node`への変更が`to_node`に与える影響の方向性（正か負か）を判断する。
            3.  影響の度合いを考慮し、評価スケールから最も適切な値を選択する。
            4.  なぜその値を選んだのか、生産技術の観点から具体的な理由を述べる。
        *   **出力形式 (厳守):** 結果は必ず以下のキーを持つJSON形式で出力してください。他の説明文は不要です。
            ```json
            {
              "score": (評価スコア),
              "reason": "思考プロセスを含む評価の具体的な理由"
            }
            ```
    *   APIからのレスポンス（JSON文字列）をPythonの辞書にパースし、`from_node`と`to_node`の情報を追加してください。
    *   **データ保存:**
        *   `project_data['evaluations']` (辞書のリスト) 内を検索し、同じ `from_node` と `to_node` のペアが既に存在するか確認します。
        *   存在すれば、その辞書を新しい評価結果で更新します。
        *   存在しなければ、新しい評価結果の辞書をリストに追加します。
    *   処理が完了したら、`st.success("評価が完了しました。")` を表示します。
    *   `json.JSONDecodeError` やAPIエラーに備えた `try-except` ブロックを実装してください。
3.  **評価結果の表示:**
    *   評価ボタンの下に、現在のペアに対する評価結果が `project_data['evaluations']` に存在する場合、そのスコアと理由を表示するエリアを設けてください。(例: `st.write` や `st.expander`)

**コード品質への要求:**
*   OpenAI APIへのリクエスト部分は、`evaluate_node_pair(from_node, to_node)` のような独立した関数にしてください。
*   システムプロンプトが長くなるため、可読性の高いf-stringで記述してください。
*   セッションステート内のリストを更新するロジックは、慎重に実装してください。

この要件に基づき、`app.py`を更新するコードを生成してください。```

---

### **【ステップ6/7】評価結果の行列化とヒートマップ可視化**

**目的:** 全てのペア評価が完了（あるいはある程度進んだ）後、その結果をまとめて一つの隣接行列に変換し、Seabornライブラリを使ってヒートマップとして可視化します。これにより、プロセス全体の相関関係が一目でわかるようになります。

**Claudeへのプロンプト:**

```markdown
ステップ5の実装、お疲れ様でした。評価機能が完成し、アプリケーションは非常に価値あるものになりました。
最後の仕上げとして、蓄積された評価データを集約し、分析・可視化する機能を実装します。このステップでは、評価結果を隣接行列に変換し、ヒートマップで表示します。

**前提:**
*   ステップ5までのコードに追記・修正します。
*   `project_data['evaluations']` に複数の評価結果が保存されている状態を想定します。

**要件:**
1.  **ライブラリの追加:** `pandas`, `numpy`, `seaborn`, `matplotlib.pyplot` をインポートしてください。
2.  **UIの追加:**
    *   メイン画面に「5. 分析と可視化」という最上位の見出しを追加します。
    *   その下に「5.1. 隣接行列ヒートマップ」という小見出しと、「行列を生成して可視化」ボタンを設置してください。
3.  **行列生成ロジック:**
    *   「行列を生成して可視化」ボタンが押されたら、以下の処理を実行します。
    *   `project_data['evaluations']` が空の場合は、`st.warning` を表示して処理を中断してください。
    *   評価結果のリストを元に、Pandas DataFrame (`pd.DataFrame`) を作成します。カラムは `from_node`, `to_node`, `score` です。
    *   `DataFrame.pivot_table()` メソッドを使い、`index='from_node'`, `columns='to_node'`, `values='score'` を指定して、評価結果を隣接行列の形式に変換（ピボット）してください。
    *   ピボット後の行列には評価されなかったペアに対応する欠損値 (`NaN`) が含まれる可能性があります。`.fillna(0)` を使って、これらを `0` (無関係) で埋めてください。
    *   行列のインデックスとカラムが、`project_data['nodes']` の全てのノードを含み、かつ同じ順序になるように、`.reindex()` を使って整形してください。これにより、完全な正方行列が保証されます。
    *   完成したDataFrame（隣接行列）をNumPy配列に変換し、`project_data['adjacency_matrix']` に保存してください。
4.  **ヒートマップ可視化ロジック:**
    *   生成した行列（DataFrame形式のままが望ましい）を `seaborn.heatmap()` に渡してヒートマップを描画します。
    *   **ヒートマップのオプション:**
        *   `annot=True`: 各セルにスコア数値を表示します。
        *   `cmap='coolwarm'`: 色のマップを指定します。正の相関が暖色系、負の相関が寒色系になるようにします。
        *   `linewidths=.5`: セル間に線を描画します。
        *   `vmin=-9, vmax=9`: カラーバーの最小値と最大値を評価スケールに合わせます。
    *   `matplotlib.pyplot` を使って、グラフのタイトルや軸ラベルを適切に設定し、図のサイズを調整してください。
    *   最終的なグラフオブジェクトを `st.pyplot(fig)` を使ってStreamlit上に表示してください。
5.  **データ表示 (任意):**
    *   可視化の下に、生成された隣接行列のDataFrame自体を `st.dataframe()` で表示する機能も追加してください。

**コード品質への要求:**
*   データ変換（リスト→DataFrame→ピボット→行列）のパイプラインは、一つの関数にまとめるなどして、可読性を高く保ってください。
*   Matplotlib/Seabornの描画コードは定型的なので、コメントを付けて各行の役割を明確にしてください。

この要件を満たす更新コードを生成してください。